This is core/es, which is a much less useful version of es-shell.

Goals:
 - Total C-code minimality
 - Generality + extensibility -- you could build a shell/es and a lang/es
 - "Primitivizing" es-shell behaviors (e.g., fork/exec)
 - Improvements and optimizations to the "core" parts of es

"Anti-features" compared to es-shell:
 - No free carets
 - No syntax rewriting (e.g., ||, &&, implicit %seq, fn command, etc.)
 - No fork/exec (and, ergo, no piping)
 - No cd or filesystem interaction (just echo and %read)
 - No definable signal handling
 - No `for` (use `apply` instead)
 - No `let` syntax -- it's been eaten as part of LEXICAL UNIFICATION
 - No `local` syntax -- it's a regular function now
 - No readline/editline/etc.
 - No run flags, no "please run this file" argument, etc.
 - Lambdas do not catch return -- Ergo, $&noreturn doesn't exist
 - No implicit * binding in lambdas (`@ {}` becomes `{}`) (LEXICAL UNIFICATION)
 - No $1, $2, etc. (use $*(1), $*(2), ya dinguses)
 - No "interactive" vs. "non-interactive" distinction -- just es:main
 - No environment interaction
 - Many builtins have been replaced by es functions

Ideas/todo:
 - there's no reason core/es needs to flatten lists -- that's just a fork/exec usability thing. what happens when we allow nested lists?
 - why are settor functions magic? we ought to unmagic them!
 - tail-call optimization -- trampoline eval()? need to look at how that works
 - first-class bindings
 - reimplement parser so we can run es code in more places (the grammar is actually quite simple)
 - I will make fn-fn if it kills me (or maybe that should be es:fn? :)
    - this is basically required now that lambdas don't catch return

To merge into es-shell:
 - es-implemented %whatis that calls %pathsearch
 - lexical unification (with `let` as a syntax frontend -- like `let` vs. `closure` now)
    - this kind of requires lambdas don't catch return by default ... is that ok?
 - fork, exec, and wait are all primitives.  spawning a binary is basically
        `%wait <={%fork {%exec /path/to/bin arg arg}}`
    - %background is that, just without the $&wait :) (or something more clever, like adding to
        a $child-pids list and waiting for children on each prompt)
    - %backquote is a primitive still?

BEFORE trying to make shell/es:
 - first-class bindings, so we can rebuild for and local syntax -- the lambda versions are less flexible
 - tail call optimization (via trampolining?) - we build big stacks with more es-centric syntax
 - fix all memory/GC bugs on this layer! before trying to add layers! !!!
 - performance improvements ??? HAOW -- look up Tcl?
 - figure out how we want to do things like {get,set}env

REQUIRED to make shell/es:
 - detecting interactive (or not) input
 - how to do syntax extensions (e.g., piping, redirections)
 - how to do added primitives (e.g., fork/exec, redirections, chdir)
 - how to do input extensions (basically, readline/editline)

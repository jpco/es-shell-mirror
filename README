This is es-core, which is a much less useful version of es.

It's intended to be a testbed for a few different ideas in es development:
 - Total C-code minimality
 - Extensions -- potentially, es-shell could be an extension of es-core in
   some way?  Could something else (es-lang) also do that at the same time?
 - "Systematizing" es' "non-core" features (e.g., fork/exec)
 - Improvements and optimizations to the "core" parts of es (first-class
   bindings, tail-call optimization, lexical bindings, the GC, etc.)

Some anti-features of es-core:
 - Cannot run any external commands
 - No free carets
 - No syntax rewriting (e.g., ||, &&, implicit %seq, fn command, etc.)
 - No fork/exec (and, ergo, no piping)
 - No cd (this may have been a mistake to remove?)
 - No definable signal handling
 - No `for` (use `apply` instead) (let and local are still there, though, FOR NOW)
 - No readline/editline/etc.
 - No run flags, no "please run this file" argument, etc.
 - No $&whatis (it has been replaced with a carefully-written function)
 - Lambdas do not catch return -- Ergo, $&noreturn doesn't exist
 - No implicit $* variable in lambdas (`@ {}` becomes `{}`)
 - No "interactive" vs. "non-interactive" distinction -- just %input-loop
 - No environment interaction

Future non-features:
 - How do we make variable access/assignment a primitive? :)

Random thoughts:
 - %whatis can run `$&fork-exec <={%pathsearch $cmd}`! :)
